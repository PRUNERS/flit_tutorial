# Autogenerated Makefile using "flit update"
#   flit version v2.0-beta.2

FFLAGS          ?=
DEV_TARGET      ?= devrun
GT_TARGET       ?= gtrun
GT_OUT          := ground-truth.csv

UNAME_S         := Linux

# will be None if not specified in flit-config.toml
CLANG           := clang++
GCC             := g++
INTEL           := None
CLANG_TYPE      := clang
INTEL_TYPE      := intel
GCC_TYPE        := gcc

# keep only the compilers that are not None and are in the path
COMPILERS       := GCC CLANG

FLIT_INC_DIR    := /home/bentley/git/FLiT/src
FLIT_LIB_DIR    := /home/bentley/git/FLiT/lib
FLIT_DATA_DIR   := /home/bentley/git/FLiT/scripts/flitcli/../../data
FLIT_SCRIPT_DIR := /home/bentley/git/FLiT/scripts/flitcli

DEV_CXX         ?= g++
DEV_CXX_TYPE    ?= gcc
DEV_OPTL        ?= -O2
DEV_SWITCHES    ?= 

GT_CXX          := g++
GT_CXX_TYPE     := gcc
GT_OPTL         := -O2
GT_SWITCHES     := 

TEST_RUN_ARGS   := --timing-loops -1 --timing-repeats 3

ENABLE_MPI      := yes

# initalize some variables to be appended later
CC_REQUIRED     :=
DEV_CFLAGS      :=
GT_CFLAGS       :=
LD_REQUIRED     :=

RUNWRAP          = $(RUN_WRAPPER)
ifeq ($(ENABLE_MPI),yes) # If we are using MPI
  IS_OPENMPI    := $(shell mpic++ --showme:compile >/dev/null 2>&1 && echo true)
ifeq ($(IS_OPENMPI),true)
  CC_REQUIRED   += $(shell mpic++ --showme:compile 2>/dev/null)
  LD_REQUIRED   += $(shell mpic++ --showme:link 2>/dev/null)
else  # IS_OPENMPI == false
  CC_REQUIRED   += $(shell mpic++ -compile_info 2>/dev/null | \
                           cut --delimiter ' ' --field 2-)
  LD_REQUIRED   += $(shell mpic++ -link_info | cut --delimiter ' ' --field 2-)
endif # IS_OPENMPI == true
endif # ENABLE_MPI == yes

OBJ_DIR         := obj
ALL_DIRS        := $(OBJ_DIR)

CC_REQUIRED     += $(FFLAGS)
# This flag specifies NOT to build position-independent executables
CC_REQUIRED     += -fno-pie
CC_REQUIRED     += -std=c++11
CC_REQUIRED     += -I.
CC_REQUIRED     += -I$(FLIT_INC_DIR)

DEV_CFLAGS      += -g
DEV_CFLAGS      += -Wall
DEV_CFLAGS      += -Wextra
DEV_CFLAGS      += -Wuninitialized
DEV_CFLAGS      += -Wno-shift-count-overflow

# This flag specifies NOT to link as a position-independent executable
# Note: this flag does not exist in GCC 4 or GCC 5 so it will fail to compile
#       we need extra logic to check for this and conditionally add this flag
#LD_REQUIRED     += -no-pie
LD_REQUIRED     += -lm
LD_REQUIRED     += -lstdc++
ifeq ($(UNAME_S),Darwin) # If we are on a Mac OSX system
  LD_REQUIRED   += -Llib -lflit
else
  LD_REQUIRED   += -L$(FLIT_LIB_DIR) -lflit
  LD_REQUIRED   += -Wl,-rpath=$(realpath $(FLIT_LIB_DIR))
endif

# Helper functions to determine if the compiler is a particular version of GCC

# Returns the compiler name as output by the --version flag
# @param 1: executable name or path to compiler
GET_COMPILER     = $(shell $1 --version | head -n 1 | awk '{ print $$1 }')

# Returns the version of the compiler as returned by -dumpversion
# @param 1: executable name or path to compiler
GET_COMPILER_VER = $(shell $1 -dumpversion)

# Returns 1 if the major version matches else 0
# @param 1: executable name or path to compiler
# @param 2: major version number as an integer
IS_MAJOR_VER     = $(shell expr substr $(call GET_COMPILER_VER,$1) 1 1 = $2)

# Returns 1 if the compiler is GCC version 4 or version 5
# @param 1: executable name or path to compiler
IS_VER_4_OR_5    = $(shell expr $(call IS_MAJOR_VER,$1,4) \| \
                                $(call IS_MAJOR_VER,$1,5))

DEV_LDFLAGS      =
GT_LDFLAGS       =

# Note: needs dependency out filename after this variable
DEPFLAGS        += -MMD -MP -MF

# TODO: deprecated.  Remove in FLiT version 3.0
TESTS            = $(wildcard tests/*.cpp)
SOURCE           = $(wildcard *.cpp)
SOURCE          += $(TESTS)

.PHONY: help
help:
	@echo 'You can run the Makefile directly, but it is recommended to use'
	@echo
	@echo '  flit make'
	@echo
	@echo 'so that you can have functionality such as adding the results to a'
	@echo 'database.'
	@echo
	@echo 'The following targets are available:'
	@echo
	@echo '  help        Show this help and exit (default target)'
	@echo '  dev         Only run the devel compilation to test things out'
	@echo '  dirs        Make only the directories, no files'
	@echo '  groundtruth Compile the ground-truth version'
	@echo '  gt          Same as groundtruth'
	@echo '  runbuild    Build all executables needed for the run target'
	@echo '  run         Run all combinations of compilation, results in results/'
	@echo '  clean       Clean intermediate files'
	@echo '  veryclean   Runs clean + removes targets and results'
	@echo '  distclean   Same as veryclean'
	@echo

# Note: having this include at the end breaks the makefile for when users add
# to SOURCE from custom.mk
-include custom.mk

# sort and remove duplicates
# TODO: Remove in FLiT version 3.0
SOURCE          := $(sort $(SOURCE))

# We are done adding to VPATH, so consolidate it for speed (removing duplicates)
VPATH           := $(sort $(VPATH))

DEV_OBJ_DIR     := $(OBJ_DIR)/dev
ALL_DIRS        += $(DEV_OBJ_DIR)
DEV_OBJ         := $(addprefix $(DEV_OBJ_DIR)/,$(notdir $(SOURCE:%=%.o)))
DEV_DEPS        := $(DEV_OBJ:%.o=%.d)
GT_OBJ_DIR      := $(OBJ_DIR)/gt
ALL_DIRS        += $(GT_OBJ_DIR)
GT_OBJ          := $(addprefix $(GT_OBJ_DIR)/,$(notdir $(SOURCE:%=%.o)))
GT_DEPS         := $(GT_OBJ:%.o=%.d)
GT_OBJ_FPIC     := $(GT_OBJ:%.o=%_fPIC.o)

HOSTNAME        := yoga-manjaro

RESULTS_DIR     := results
ALL_DIRS        += $(RESULTS_DIR)

# on systems with non-standard gcc installations (such as module), clang may
# be unable to determine the correct gcc toolchain
CLANG_REQUIRED  :=
ifeq ($(findstring GCC,$(COMPILERS)),GCC)
GCC_TOOLCHAIN   := $(dir $(shell which $(GCC) 2>/dev/null))/..
CLANG_REQUIRED  += --gcc-toolchain=$(GCC_TOOLCHAIN)
endif

ifeq ($(DEV_CXX_TYPE),$(CLANG_TYPE))
DEV_CFLAGS      += $(CLANG_REQUIRED)
endif
ifeq ($(GT_CXX_TYPE),$(CLANG_TYPE))
GT_CFLAGS       += $(CLANG_REQUIRED)
endif

# Compiler setting targets
#   taken from: https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html
#   among other places
# more comp settings, taken from here:
# https://software.intel.com/sites/default/files/article/326703/fp-control-2012-08.pdf

# individual flags

## optls

O3              := -O3

## switches

FRECIPROCAL_MATH := -freciprocal-math
FUNSAFE_MATH_OPTIMIZATIONS := -funsafe-math-optimizations
MAVX2__MFMA     := -mavx2 -mfma
NO_FLAGS        := 

OPCODES_GCC     :=
OPCODES_GCC     += O3

OPCODES_CLANG   :=
OPCODES_CLANG   += O3

SWITCHES_GCC    :=
SWITCHES_GCC    += FRECIPROCAL_MATH
SWITCHES_GCC    += FUNSAFE_MATH_OPTIMIZATIONS
SWITCHES_GCC    += MAVX2__MFMA
SWITCHES_GCC    += NO_FLAGS

SWITCHES_CLANG  :=
SWITCHES_CLANG  += FRECIPROCAL_MATH
SWITCHES_CLANG  += FUNSAFE_MATH_OPTIMIZATIONS
SWITCHES_CLANG  += NO_FLAGS

##########################################################
#
# Now to define the recursion for speed and memory reasons
#
##########################################################

# Compiles a single object file from a source file given compiler and flags
# @param 1: source file
# @param 2: object file
# @param 3: compiler
# @param 4: optimization level
# @param 5: switches
# @param 6: target filename
# @param 7: extra compiler flags
define COMPILE_RULE
$2: $1 Makefile custom.mk | $(patsubst %/,%,$(dir $2))
	$3 $4 $5 -c $7 $(CC_REQUIRED) $(DEPFLAGS) $(2:%.o=%.d) $1 -o $2 \
	  -DFLIT_HOST='"$(HOSTNAME)"' \
	  -DFLIT_COMPILER='"$(strip $3)"' \
	  -DFLIT_OPTL='"$(strip $4)"' \
	  -DFLIT_SWITCHES='"$(strip $5)"' \
	  -DFLIT_FILENAME='"$(notdir $(strip $6))"'
endef

REC_DIRS        := $(foreach c, $(COMPILERS),\
                     $(foreach s, $(SWITCHES_$(strip $c)),\
                       $(foreach o, $(OPCODES_$(strip $c)),\
                         $(OBJ_DIR)/$c_$(HOSTNAME)_$s_$o)))
ALL_DIRS        += $(REC_DIRS)

RUNBUILD_DIR := bin
ALL_DIRS     += $(RUNBUILD_DIR)

# will be set internally when doing recursive calls.  Get set to variable names
# containing the information (e.g. R_CUR_COMPILER=CLANG)
R_CUR_COMPILER  ?=
R_CUR_OPTL      ?=
R_CUR_SWITCHES  ?=

.PHONY: dirs
dirs: $(ALL_DIRS)

$(ALL_DIRS):
	mkdir -p $@

# If we are in a recursion
ifdef R_IS_RECURSED

R_ID            := $(R_CUR_COMPILER)_$(HOSTNAME)_$(R_CUR_SWITCHES)_$(R_CUR_OPTL)
R_TARGET        := $(RUNBUILD_DIR)/$(R_ID)
R_OBJ_DIR       := $(OBJ_DIR)/$(R_ID)
R_OBJ           := $(addprefix $(R_OBJ_DIR)/,$(notdir $(SOURCE:%=%.o)))
R_DEP           := $(R_OBJ:%.o=%.d)

-include $(R_DEP)

.PHONY: rec
rec: $(R_TARGET)

# clang's flag is -nopie
# else if the current compiler is not GCC 4 or 5, then enable -no-pie
# GCC 4 and 5 do not need -no-pie since that is the default
ifeq ($($(R_CUR_COMPILER)_TYPE),$(CLANG_TYPE))
  LD_REQUIRED += -nopie
else ifeq ($($(R_CUR_COMPILER)_TYPE),$(GCC_TYPE))
ifeq ($(call IS_VER_4_OR_5,$($(R_CUR_COMPILER))),0)
  LD_REQUIRED += -no-pie
endif
endif

$(R_TARGET): $(R_OBJ) | $(RUNBUILD_DIR)
	$($(R_CUR_COMPILER)) $($(R_CUR_OPTL)) $($(R_CUR_SWITCHES)) \
	  $($(R_CUR_COMPILER)_REQUIRED) $(CC_REQUIRED) \
	  $(R_OBJ) -o $@ \
	  $(LD_REQUIRED)

$(foreach s,$(SOURCE), \
  $(eval $(call COMPILE_RULE,\
    $s,\
    $(R_OBJ_DIR)/$(notdir $s).o,\
    $($(R_CUR_COMPILER)),\
    $($(R_CUR_OPTL)),\
    $($(R_CUR_SWITCHES)),\
    $(R_ID),\
    $($(R_CUR_COMPILER)_REQUIRED))))

# Otherwise, we're not in a recursion.
else # ifndef R_IS_RECURSED

# clang's flag is -nopie
# else if the current compiler is not GCC 4 or 5, then enable -no-pie
# GCC 4 and 5 do not need -no-pie since that is the default
ifeq ($(DEV_CXX_TYPE),$(CLANG_TYPE))
  DEV_LDFLAGS   += -nopie
else ifeq ($(DEV_CXX_TYPE),$(GCC_TYPE))
ifeq ($(call IS_VER_4_OR_5,$(DEV_CXX)),0)
  DEV_LDFLAGS   += -no-pie
endif
endif

# same for the gt compiler
ifeq ($(GT_CXX_TYPE),$(CLANG_TYPE))
  GT_LDFLAGS    += -nopie
else ifeq ($(GT_CXX_TYPE),$(GCC_TYPE))
ifeq ($(call IS_VER_4_OR_5,$(GT_CXX)),0)
  GT_LDFLAGS    += -no-pie
endif
endif

#
# Define the recursion rules
#

# Set these as empty "simply-expanded variables".  This affects the "+=" operator.
# see https://ftp.gnu.org/old-gnu/Manuals/make-3.79.1/html_chapter/make_6.html
TARGET_OUTS  :=

# @param 1: compiler variable name (e.g. CLANG)
# @param 2: optimization level variable name (e.g. O2)
# @param 3: switches variable name (e.g. USE_FAST_MATH)
define RECURSION_RULE
TARGETS     += $$(RUNBUILD_DIR)/$(strip $1)_$$(HOSTNAME)_$(strip $3)_$(strip $2)

# TODO: use the variable $$(MAKECMDGOALS) to get the original make target
# TODO- or see if it is even necessary

# Make the recursive target depend on $$(GT_TARGET), not because it actually
# depends on that target, but we know that when $$(GT_TARGET) needs to be
# rebuilt, so does each recursive target.

$$(RUNBUILD_DIR)/$(strip $1)_$$(HOSTNAME)_$(strip $3)_$(strip $2): $$(GT_TARGET) | $$(OBJ_DIR) $$(RUNBUILD_DIR)
	-+@$$(MAKE) rec --no-print-directory \
	  R_IS_RECURSED=True \
	  R_CUR_COMPILER=$(strip $1) \
	  R_CUR_OPTL=$(strip $2) \
	  R_CUR_SWITCHES=$(strip $3)
	-test -f $$(RUNBUILD_DIR)/$(strip $1)_$$(HOSTNAME)_$(strip $3)_$(strip $2)

endef

$(foreach c, $(COMPILERS),                 \
  $(foreach s, $(SWITCHES_$(strip $c)),    \
    $(foreach o, $(OPCODES_$(strip $c)),               \
      $(eval $(call RECURSION_RULE, $c, $o, $s)))))
TARGET_OUTS     := $(addprefix $(RESULTS_DIR)/,$(notdir $(TARGETS:%=%-out)))
TARGET_RESULTS  := $(TARGET_OUTS:%=%-comparison.csv)

$(RESULTS_DIR)/%-out: $(RUNBUILD_DIR)/% | $(RESULTS_DIR)
	$(RUNWRAP) ./$< $(TEST_RUN_ARGS) --output $@ || touch $@

# specify how to get comparison
%-out-comparison.csv: %-out $(GT_OUT) $(GT_TARGET)
	$(RUNWRAP) ./$(GT_TARGET) --compare-mode --compare-gt $(GT_OUT) --suffix "-comparison.csv" $< -o /dev/null

#
# Define the recursion rules
#

OBJ_CLEAN        = $(addprefix $(OBJ_DIR)/,$(notdir $(SOURCE:%=%_*.o)))
DEP_CLEAN       += $(OBJ_CLEAN:%.o=%.d)

.PHONY: dev gt gt-fpic groundtruth run runbuild
dev: $(DEV_TARGET)
gt: groundtruth
gt-fpic: $(GT_OBJ_FPIC)
groundtruth: $(GT_TARGET)

run: $(TARGET_RESULTS) $(TARGET_OUTS)
run: $(GT_OUT)
run: runbuild
runbuild: $(TARGETS) groundtruth

.PHONY: clean
clean:
	rm -rf $(OBJ_DIR)

.PHONY: veryclean distclean
veryclean: distclean
distclean: clean
	rm -rf $(RESULTS_DIR)
	rm -rf $(RUNBUILD_DIR)
	rm -f $(DEV_TARGET)
	rm -f $(GT_TARGET)
	rm -f $(GT_OUT)
	rm -f $(addsuffix *.dat,$(GT_OUT))

Makefile: flit-config.toml
Makefile: $(FLIT_DATA_DIR)/Makefile.in
Makefile: $(FLIT_SCRIPT_DIR)/flitconfig.py
Makefile: $(FLIT_SCRIPT_DIR)/flitutil.py
Makefile: $(FLIT_SCRIPT_DIR)/flit_update.py
	$(FLIT_SCRIPT_DIR)/flit.py update


# We have a different solution if we are on a mac
ifeq ($(UNAME_S),Darwin)
ALL_DIRS       += lib
lib/libflit.so: $(FLIT_LIB_DIR)/libflit.so | lib
	cp $< $@

.PHONY: cleanlibflit
distclean: cleanlibflit
cleanlibflit:
	rm -rf lib

$(DEV_TARGET): lib/libflit.so
$(GT_TARGET):  lib/libflit.so
$(TARGETS):    lib/libflit.so
else
$(DEV_TARGET): $(FLIT_LIB_DIR)/libflit.so
$(GT_TARGET):  $(FLIT_LIB_DIR)/libflit.so
$(TARGETS):    $(FLIT_LIB_DIR)/libflit.so
endif # ifeq ($(UNAME_S),Darwin): meaning, we are on a mac

# include the build dependencies for gt and dev

-include $(GT_DEPS)
-include $(DEV_DEPS)

#
# Now for the compilation rules:
#

# Dev compilation rules first (easier to understand)
$(DEV_TARGET): $(DEV_OBJ) Makefile custom.mk
	$(DEV_CXX) $(CC_REQUIRED) $(DEV_CFLAGS) \
	  -o $@ $(DEV_OBJ) $(LD_REQUIRED) $(DEV_LDFLAGS)

$(foreach s,$(SOURCE),\
  $(eval $(call COMPILE_RULE,\
    $s,\
    $(DEV_OBJ_DIR)/$(notdir $s).o,\
    $(DEV_CXX),\
    $(DEV_OPTL),\
    $(DEV_SWITCHES),\
    $(DEV_TARGET),\
    $(DEV_CFLAGS))))

# Ground truth compilation rules
$(GT_OUT): $(GT_TARGET)
	$(RUNWRAP) ./$(GT_TARGET) --output $(GT_OUT) --no-timing

$(GT_TARGET): $(GT_OBJ) Makefile custom.mk
	$(GT_CXX) $(CC_REQUIRED) $(GT_CFLAGS) \
	  -o $@ $(GT_OBJ) $(LD_REQUIRED) $(GT_LDFLAGS)

$(foreach s,$(SOURCE),\
  $(eval $(call COMPILE_RULE,\
    $s,\
    $(GT_OBJ_DIR)/$(notdir $s).o,\
    $(GT_CXX),\
    $(GT_OPTL),\
    $(GT_SWITCHES),\
    $(GT_TARGET),\
    $(GT_CFLAGS) -g)))

$(foreach s,$(SOURCE),\
  $(eval $(call COMPILE_RULE,\
    $s,\
    $(GT_OBJ_DIR)/$(notdir $s)_fPIC.o,\
    $(GT_CXX),\
    $(GT_OPTL),\
    $(GT_SWITCHES),\
    $(GT_TARGET),\
    $(GT_CFLAGS) -fPIC -g)))

endif # end of ifdef R_IS_RECURSED

